## 检索数据

>SELECT的作用是从一个表或多个表中检索出想要的数据行。

### 一：SELECT查询的基础语法
 SELECT可以帮助我们从一个表或多个表中进行数据查询。我们知道一个数据表是由列（字段名）和行（数据行）组成的，我们要返回满足条件的数据行，就需要在SELECT后面加上我们想要查询的列名，可以是一列，也可以是多个列。如果你不知道所有列名都有什么也可以检索所有列。

 #### 查询列
 如果我们想要对数据表中的某一列进行检索，在SELECT后面加上这个列的字段名即可。比如我们想要检索数据表中都有哪些英雄。
 ```
 SELECT name FROM heros;
 ```
 我们也可以对多个列进行检索，在列名之间用逗号（,）分割即可。比如我们想要检索有哪些英雄，他们的最大生命、最大法力、最大物攻和最大物防分别是多少。
 ```
 SELECT name, hp_max, mp_max, attack_max, defense_max FROM heros;
 ```
 如果我们记不住所有的字段名称，可以使用`SELECT *`帮我们检索出所有的列，虽然我们在做数据检索的时候，`SELECT *`很有用，不需要写很长的SELECT语句，但是在生产环境时要尽量避免使用`SELECT *`。

 #### 起别名
 我们在使用SELECT查询的时候，还有一些技巧可以使用，比如你可以给列名起别名`AS`。我们在进行检索的时候，可以给英雄名、最大生命、最大法力、最大物攻和最大物防等取别名：
 ```
 SELECT name AS n, hp_max AS hm, mp_max AS mm, attack_max AS am, defense_max AS dm FROM heros;
 ```
 运行结果和上面多列检索的运行结果是一样的，只是将列名改成了n、hm、mm、am和dm。当然这里的列别名只是举例，一般来说起别名的作用是对原有名称进行简化，从而让SQL语句看起来更精简。同样我们也可以对表名称起别名，这个在多表连接查询的时候会用到。

 #### 查询常数
 SELECT查询还可以对常数进行查询。就是在SELECT查询结果中增加一列固定的常数列。这列的取值是我们指定的，而不是从数据表中动态取出的。一般来说我们只从一个表中查询数据，通常不需要增加一个固定的常数列，但如果我们想整合不同的数据源，用常数列作为这个表的标记，就需要查询常数。

 比如说，我们想对heros数据表中的英雄名进行查询，同时增加一列字段platform，这个字段固定值为“王者荣耀”，可以这样写：
 ```
 SELECT '王者荣耀' as platform, name FROM heros;
 ```
 需要说明的是，如果常数是个字符串，那么使用单引号`（' '）`就非常重要了，比如`'王者荣耀'`。单引号说明引号中的字符串是个常数，否则SQL会把`王者荣耀`当成列名进行查询，但实际上数据表里没有这个列名，就会引起错误。如果常数是英文字母，比如`'WZRY'`也需要加引号。如果常数是个数字，就可以直接写数字，不需要单引号，比如：
 ```
 SELECT 123 as platform, name FROM heros;
 ```

 #### 去除重复行
 关于单个表的SELECT查询，还有一个非常实用的操作，就是从结果中去掉重复的行。使用的关键字是`DISTINCT`。比如我们想要看下heros表中关于攻击范围的取值都有哪些：
 ```
 SELECT DISTINCT attack_range FROM heros;
 ```
 这里有两点需要注意：
 1. `DISTINCT`需要放到所有列名的前面，如果写成`SELECT name, DISTINCT attack_range FROM heros`会报错。
 2. `DISTINCT`其实是对后面所有列名的组合进行去重，你能看到最后的结果是69条，因为这69个英雄名称不同，都有攻击范围（attack_range）这个属性值。如果你想要看都有哪些不同的攻击范围（attack_range）,只需要写`DISTINCT attack_range`即可，后面不需要再加其他的列名了。

 #### 如何排序检索数据
 当我们检索数据的时候，有时候需要按照某种顺序进行结果的返回，比如我们想要查询所有的英雄，按照最大生命从高到低的顺序进行排序，就需要`ORDER BY`子句。使用`ORDER BY`子句有以下几个点需要掌握：
 1. **排序的列名**：`ORDER BY`后面可以有一个或多个列名，如果是多个列名进行排序，会按照后面第一个列先进行排序，当第一列的值相同的时候，再按照第二列进行排序，以此类推。
 2. **排序的顺序**：`ORDER BY`后面可以注明排序规则，`ASC`代表递增排序，`DESC`代表递减排序。如果没有注明排序规则，默认情况下是按照ASC递增排序。我们很容易理解`ORDER BY`对数值类型字段的排序规则，但如果排序字段类型为文本数据，就需要参考数据库的设置方式了，这样才能判断A是在B之前，还是在B之后。比如使用MySQL在创建字段的时候设置为`BINARY`属性，就代表区分大小写。
 3. **非选择排序**：`ORDER BY`可以使用非选择列进行排序，所以即使在`SELECT`后面没有这个列名，你同样可以放到`ORDER BY`后面进行排序。
 4. **`ORDER BY`的位置**：`ORDER BY`通常位于`SELECT`语句的最后一条子句，否则会报错。

 #### 约束返回结果的数量
 另外在查询过程中，我们可以约束返回结果的数量，使用`LIMIT`关键字。比如我们想要返回英雄名称及最大生命值，按照最大生命值从高到低排序。需要放到`SELECT`语句的最后面。

 返回约束结果的数量可以减少数据表的网络传输量，也可以提升查询效率。如果我们知道返回结果只有1条，就可以使用`LIMIT 1`，告诉`SELECT`语句只需返回一条记录即可。这样的好处就是`SELECT`不需要扫描完整的表，只需要检索到一条符合条件的记录即可返回。

 #### SELECT的执行顺序
 1. <font color=orange>**关键字的顺序是不能颠倒的：**</font>
 ```
 SELECT ... FROM ... WHERE ... GROUP BY ... HAVING ... ORDER BY ...
 ```
 2. <font color=orange>**`SELECT`语句的执行顺序：**</font>
 ```
 FROM > WHERE > GROUP BY > HAVING > SELECT 的字段 > DISTINCT > ORDER BY > LIMIT
 ```
 比如你写一个SQL语句，那么它的关键字顺序和执行顺序是下面这样的：
 ```
 SELECT DISTINCT player_id, player_name, count(*) AS num  ## 顺序5
 FROM player JOIN team ON player.team_id = team.team_id ## 顺序1
 WHERE height > 1.80 ## 顺序2
 GROUP BY player.team_id ## 顺序3
 HAVING num > 2  ## 顺序4
 ORDER BY num DESC ## 顺序6
 LIMIT 2 ## 顺序7
 ```
 在`SELECT`语句执行这些步骤的时候，每个步骤都会产生一个虚拟表，然后将这个虚拟表传入下一个步骤中作为输入。需要注意的是，这些步骤隐含在SQL的执行过程中，对于我们来说是不可见的。

 这里详细解释一下SQL的执行原理。首先，我们可以注意到，`SELECT`是先执行`FROM`这一步的。在这个阶段，如果是多张表联查，还会经历下面的几个步骤：
 1. 首先通过`CROSS JOIN`求笛卡尔积，相当于得到虚拟表vt（virtual table）1-1
 2. 通过ON进行筛选，在虚拟表vt1-1的基础上进行筛选，得到虚拟表vt1-2
 3. 添加外部行。如果我们使用的是左连接、右连接或者全连接，就会涉及到外部行，也就是在虚拟表vt1-2的基础上增加外部行，得到虚拟表vt1-3

 当然如果我们操作的是两张以上的表，还会重复上面的步骤，直到所有表都被处理完为止。这个过程得到的是我们的原始数据。当我们拿到了查询数据表的原始数据，也就是最终的虚拟表vt1，就可以在此基础上再进行`WHERE`阶段。在这个阶段中，会根据vrt1表的结果进行筛选过滤，得到虚拟表vt2。

 然后进入第三步和第四步，也就是`GROUP`和`HAVING`阶段。在这个阶段中，实际上是在虚拟表vt2的基础上进行分组和分组过滤，得到中间的虚拟表vt3和vt4。当我们完成了条件筛选部分之后，就可以筛选表中提取的字段，也就是进入到`SELECT`和`DISTINCT`阶段。

 首先在`SELECT`阶段会提取想要的字段，然后在`DISTINCT`阶段过滤掉重复的行，分别得到中间的虚拟表vt5-1和vt5-2。当我们提取了想要的字段数据之后，就可以按照指定的字段进行排序，也就是`ORDER BY`,得到虚拟表vt6。

 最后在vt6的基础上，取出指定行的记录，也就是`LIMIT`阶段，得到最终的结果，对应的是虚拟表vt7。当然我们在写`SELECT`语句的时候，不一定存在所有的关键字，相应的阶段就会省略。

 同时因为SQL是一门类似英语的结构化查询语言，所以我们在写`SELECT`语句的时候，还要注意相应的关键字顺序，所谓底层运行的原理，就是我们刚才讲到的执行顺序。

 #### 什么情况下用`SELECT *`，如何提升`SELECT`查询效率？
 虽然使用`SELECT *`，因为使用方便。实际上这样也增加了数据库的负担。所以如果我们不需要把所有列都检索出来，还是先指定出所需的列名，因为写清列名，可以减少数据表查询的网络传输量，而且考虑到在实际的工作中，我们往往不需要全部的列名，因此你需要养成良好的习惯，写出所需的列名。

 如果我们只是练习，或者对数据进行探索，那么是可以使用`SELECT *`的。它的查询效率和把所有列名都写出来再进行查询的效率相差并不大。这样可以方便你对数据表有个整体的认知。但是在生产环境下，不推荐直接使用`SELECT *`进行查询。