## Go逃逸分析

### 堆和栈
+ **堆（Heap）**：一般来讲是人为手动进行管理，手动申请、分配、释放。堆适合不可预知大小的内存分配，这也意味着为此付出的代价是分配速度较慢，而且会形成内存碎片。
+ **栈（Stack）**：由编译器进行管理，自动申请、分配、释放。一般不会太大，因此栈的分配和回收速度非常快；我们常见的函数参数（不同平台允许存放的数量不同），局部变量等都会存放在栈上。

栈分配内存只需要两个CPU指令：“PUSH”和“RELEASE",分配和释放；而堆分配内存首先需要去找到一块大小合适的内存块，之后要通过垃圾回收才能释放。

通俗来说，**栈**就好比去饭馆吃饭，只需要点菜`发出申请PUSH`--->吃饭`使用内存`---->吃饱就走剩下的交给饭馆`操作系统自动回收/GC`。而**堆**就好比在家里做饭，小到买什么菜，每一个环节都需要自己来实现，但是自由度会大很多。

### 什么是逃逸分析
在编译程序优化理论中，逃逸分析是一种确定指针动态范围的方法，简单来说就是分析在程序的哪些地方可以访问到该指针。

简单来说，Go是通过在编译器里做逃逸分析（escape analysis）来决定一个对象放在栈上还是放在堆上，不逃逸的对象放在`栈`上，可能逃逸的放在`堆`上；即我发现`变量`在退出函数后没有用了，那么就把它丢到`栈`上。反之，函数内部的普通变量经过`逃逸分析`后，发现在函数退出后`变量`还有在其他地方引用，那就将`变量`分配在堆上。做到按需分配。

### 为何需要逃逸分析
1. 减少`GC`的压力，栈上的变量，随着函数退出后系统直接回收，不需要`GC`标记后再清除
2. 减少内存碎片的产生
3. 减轻分配堆内存的开销，提高程序的运行速度

### 如何确定是否逃逸
在`Go`中通过逃逸分析日志来确定是否逃逸，开启逃逸分析日志：
```
go run -gcflags '-m -l' main.go 
```
+ `-m`会打印出逃逸分析的优化策略，实际上最多总共可以用4个`-m`，但是信息量较大，一般用就可以了
+ `-l`会禁用内联函数，在这里禁用掉`内联`能更好的观察逃逸情况，减少干扰。

### 案例分析--逃逸案例
#### 案例一：取地址发生逃逸
```
func main(
    var s string = "name"
    _ = getInfo(s)
)

func getInfo(s string) *string {
    return &s
}
```
执行`go run -gcflags "-m -l" main.go`后返回以下结果：
```
# command-line-arguments
.\main.go:9:9: &s escapes to heap
.\main.go:8:14: moved to heap: s
```
>getInfo函数里面的变量`s`逃逸到堆上了（分配到堆内存空间上了）。
>
>GetInfo函数的返回值为*string指针类型，然后将变量`s`的地址返回，此时编译器会判断该值可能会在函数外使用，就将其分配到了堆上，所以变量`s`就逃逸了。

对一个变量取地址，可能会被分配到堆上。但是`编译器进行逃逸分析后，如果发现到函数返回后，此变量不会被引用，那么还是会被分配到栈上`。

#### 案例二：未确定类型
对于`interface`类型，go编译器或者链接器不可能在编译的时候计算两者的对应关系，因此只能分配到`堆`上。

#### 案例三：间接赋值
